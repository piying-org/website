# 客户端介绍
- 使用通用的元数据定义在不同库/框架上实现相同的开发体验
- 使开发者更加关注于逻辑和布局,从琐碎事物中解放出来

## 为什么使用皮影?

**如果您符合以下条件,那么皮影就适合您**

- 减少维护成本
- 减少代码编写
- 表单的类型安全实现
- 视图逻辑分离
- 减少对底层框架依赖使得代码更加通用
- 更加方便的验证机制

**如果您符合以下条件,那么您可以尝试以下皮影**

- 页面之间有一些相似的逻辑,但是因为某些添加导致无法重用
- 本来可以重用的逻辑,因为某些特性添加不得复制出一份新的代码
- 希望未来代码拥有不同框架的可迁移性

**如果您符合以下条件,那么皮影不适合您**

- 希望使用皮影代替某个框架
- 提高页面性能而不是提高开发效率
  > 这并不意味着使用皮影后速度会变得很慢,由于元数据解析会有一点开销,所以一定会被之前慢一点,但是这一点可以忽略不计.
- 每个页面的实现都不相同并且没有任何可以重用的组件

## 皮影解决了哪些问题?

- 皮影对于大多数普通的表单功能都已经完全覆盖,所以下面列举的是皮影相较于主流库而言解决的问题

### 类型安全

- 市面上绝大多数的表单,都没有类型,往往设计表单后,还需要重新写一个类型来对输入输出进行约束
- 通过`valibot`定义,可以将天然的获取到类型,并且获得最基础的类型验证,保证任何情况下,数据的类型没有问题

### 统一前后端的类型及验证

- 当前后端均使用js开发时,往往遇到一个问题,就是后端的类型已经定义,但是后端返回的接口往往只有`interface`/`type`,更甚者可能连类型都没有,只是告诉有哪些字段
- 这时候使用`valibot`,获得对应的类型,及一些基础的验证
- 当通过皮影的解析加持后,相关验证可以完美的反馈到表单上,也就是前后端的限制变成了一样,只要数据可以回传,那么一定符合要求,减少维护成本,并且分担了后端的验证压力

### 使用相同代码在任意适配过的库/框架开发

- 对特定的一些渲染逻辑进行适配,使得不同库/框架上都可以使用相同代码开发
  > 不同的库,组件实现方式和一些逻辑也不同,所以需要实现一个兼容层
- 通过在配置中注册组件,使得逻辑部分完全不依赖视图中的任何内容,方便未来的迁移与维护

### 布局移动

- 绝大多数表单,都没有类型安全,即使使用了元数据定义,也无法随意移动,只能根据定义顺序来显示组件
- 皮影成功解决了这个问题,使得定义与视图并非耦合关系,允许任意显示与调整
  > 这样,你就可以定制属于设计要求的表单而不是有限的展示

### 逻辑或/与

- 绝大多数表单,只做了`Group`,`Array`,`Control`三种控件,但是缺少了逻辑或与,这就让某些逻辑实现变得复杂
- 比如JsonSchema中的`anyOf`,`oneOf`,可以轻松使用`v.intersect`,`v.union`对应的`FieldLogicGroup`进行动态切换处理

## 皮影没有解决哪些问题?

### 开箱即用的组件库

- 由于不同库/框架有着不同实现方式,所以没法实现统一的组件库
- 不同业务和审美也不可能造就统一的组件库

#### 如何处理

- 对已经适配的库/框架,存在`demo`进行了一些简单的组件实现和注册,方便大家进行修改
- 使用已有组件库进行一些属性绑定即可使用
  > 毕竟哪怕是现有的组件库,放到业务中也是要进行一些包装微调的

## 皮影如何支持不同平台

### 动态解析部分

必须实现部分,用来将定义动态解析为配置

### 静态解析部分

默认下动态解析后,大多数场景都可以直接使用

小部分场景因为视图和逻辑分离,所以需要使用静态解析,将定义先解析为对应模板并写入文件,再配合动态解析赋值

#### 举例

各个`小程序`便是视图/逻辑分离的,需要使用静态解析先生成模板

## 当前支持

- `Angular`
- `Vue`
- `React`

> 更多支持待实现
